# JUC

## AQS



### ReentrantLock 和 AQS

![](https://images.yingwai.top/picgo/202109081606646.png)

ReentrantLock内部包含了一个AQS对象，也就是 **AbstractQueuedSynchronizer（抽象队列同步器）**类型的对象。这个AQS对象就是ReentrantLock可以实现加锁和释放锁的关键性的核心组件。

### ReentrantLock 加锁和释放锁的底层原理

AQS对象内部有一个核心的变量叫做**`state`**，是`int`类型并且用`volatile`修饰的，代表了**加锁的状态**。

初始状态下，这个`state`的值是0。并且 AQS 内部还有一个**关键变量**，用来记录**当前加锁的是哪个线程**，初始状态下，这个变量是null。

![](https://images.yingwai.top/picgo/202109081606444.png)

线程1现在调用 ReentrantLock 的 `Lock()` 方法尝试进行加锁，这个加锁的过程，就是用 CAS 操作将 `state` 的值修改为1。

如果之前没别的线程加过锁，那么 `state` 的值肯定是0，此时线程1就可以加锁成功。

一旦线程1加锁成功了之后，就可以设置当前加锁线程是自己：

![](https://images.yingwai.top/picgo/202109081607115.png)

ReentrantLock之所以用Reentrant打头，意思就是他是一个可重入锁。

可重入锁的意思，就是你可以对一个ReentrantLock对象多次执行 `lock()` 加锁和 `unlock()` 释放锁，也就是可以对一个锁加多次，叫做可重入加锁。

其实每次线程1可重入加锁一次，会判断一下当前加锁线程就是自己，那么他自己就可以可重入多次加锁，每次加锁就是把 `state` 的值给累加1，别的没什么变化。

#### 实现锁的互斥

如果在线程1已经加锁的情况下，线程2也过来加锁，那么线程2会发现 state 的值不为0，因此 CAS 操作将 state 从0变为1的过程会失败。

然后线程2会查看目前加锁的线程是不是自己，而当前的 `exclusiveOwnerThread`（加锁线程变量）记录着当前加锁的线程为线程1，所以线程2会加锁失败：

![](https://images.yingwai.top/picgo/202109081607684.png)

接下来线程2会将自己放入 AQS 中的一个**等待队列**，因为自己尝试加锁失败了，此时就要将自己放入队列中来等待，等待线程1释放锁之后，自己就可以重新尝试加锁了：

![](https://images.yingwai.top/picgo/202109081607840.png)

线程1在执行完自己的业务逻辑代码之后，就会释放锁，将 AQS 内的 `state` 变量的值递减1，如果 `state` 值为0，则彻底释放锁，会将“加锁线程”变量也设置为null。

接下来会从等待队列的对头唤醒线程2重新尝试加锁：

![](https://images.yingwai.top/picgo/202109081608668.png)

AQS 中的等待队列用于存放那些加锁失败的线程，在当前独占着资源的线程释放锁后，等待队列中的线程就可以去获取锁，此时还分为公平锁和非公平锁的情况。

上面的例子是公平锁的情况。

### 公平锁与非公平锁

[阿里面试官：说一下公平锁和非公平锁的区别？_敖丙-CSDN博客](https://blog.csdn.net/qq_35190492/article/details/104943579)

#### 公平锁

多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。

- 优点：所有的线程都能得到资源，不会饿死在队列中。
- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

#### 非公平锁

多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。

- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
- 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

#### AQS 实现

两种锁的实现依赖于 AQS，区别在于公平锁的情况下，若有线程进来插队，会去查看队列中是否有线程在等待，而非公平锁是不查看队列直接尝试去获取锁。

### 参考链接

* [【深入AQS原理】我画了35张图就是为了让你深入 AQS](https://www.cnblogs.com/wang-meng/p/12816829.html)

* [Java并发之AQS详解](https://www.cnblogs.com/waterystone/p/4920797.html)

* [JavaGuide](https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/AQS原理以及AQS同步组件总结)


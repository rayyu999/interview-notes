# 275. H 指数 II

https://leetcode-cn.com/problems/h-index-ii/

## 题目描述

给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 **升序排列** 。编写一个方法，计算出研究者的 h 指数。

h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数**不多于** h 次。）"

 

**示例:**

```
输入: citations = [0,1,3,5,6]
输出: 3 
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。
```

 

**说明:**

如果 h 有多有种可能的值 ，h 指数是其中最大的那个。

 

**进阶：**

* 这是 H 指数 的延伸题目，本题中的 `citations` 数组是保证有序的。
* 你可以优化你的算法到对数时间复杂度吗？



## 思路

二分查找：

首先，对于无序的数组的情况，可以先对数组 `citations` 进行降序排序，根据数组的性质，可知 `citations[i]` 表示至少有 i 篇文章的被引用次数大于等于 `citations[i]`。于是根据题意，问题可以转化为查找数组中满足 `citations[i] >= i` 的最大的 `i`，这个 `i` 即为最后的结果。因此可以使用查找右边界的二分查找来解决：

* 初始边界为 `[0, len-1]`，跳出循环的条件为 `left > right`；
* 每次查看区间中的中间下标 `mid`，若满足条件，说明结果在 `mid` 右边（包括 `mid`），收缩左边界 `left = mid + 1`；
* 若不满足条件，说明结果在 `mid` 左边，收缩右边界 `right = mid - 1`；
* 最后 `left` 会指向第一个不满足条件的元素，而 `right = left - 1`，因此 `right` 为满足条件的右边界。

而本题给出的数组是升序排序的，因此数组中 `citations[i]` 表示至少有 `len - i` 篇文章的被引用次数大于等于 `citations[i]`，于是只要将上述解法中的判断条件改为 `citations[i] >= len - i`，再使用查找左边界的二分查找来解决即可。

最后的结果为 `len - left`。



## 代码

```java
class Solution {
    public int hIndex(int[] citations) {
        int len = citations.length;
        int l = 0, r = len-1;
        while (l <= r) {
            int mid = l + ((r - l) >> 1);
            // 升序排序，所以一共有len-mid篇文章的引用次数大于等于citations[mid]
            // 至少有len-mid篇文章被引用了citations[mid]次，继续往h指数高的方向搜索
            if (citations[mid] >= len - mid) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        // 引用次数大于等于citations[l]的文章一共有len-l篇
        return len - l;
    }
}
```


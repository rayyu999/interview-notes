# 数据结构

![](https://images.yingwai.top/picgo/20210818174754.jpeg)

各数据结构的底层实现：

![](https://images.yingwai.top/picgo/20210720220433.png ':size=60%')

## String（字符串）

Redis的字符串如果保存的对象是整数类型，那么就用int存储。如果不能用整数表示，就用SDS来表示，SDS通过记录长度，和预分配空间，可以高效计算长度，进行append操作。

![](https://images.yingwai.top/picgo/20210818174517.jpg ':size=60%')

在 Redis 内部， 字符串的追加和长度计算很常见， 而 APPEND 和 STRLEN 更是这两种操作，在 Redis 命令中的直接映射， 这两个简单的操作不应该成为性能的瓶颈。

另外， Redis 除了处理 C 字符串之外， 还需要处理单纯的字节数组， 以及服务器协议等内容， 所以为了方便起见， Redis 的字符串表示还应该是[二进制安全的](http://en.wikipedia.org/wiki/Binary-safe)： 程序不应对字符串里面保存的数据做任何假设， 数据可以是以 `\\0` 结尾的 C 字符串， 也可以是单纯的字节数组， 或者其他格式的数据。

考虑到这两个原因， Redis 使用 sds 类型替换了 C 语言的默认字符串表示： sds 既可高效地实现追加和长度计算， 同时是二进制安全的。

**参考链接：**

* [简单动态字符串 - Redis 设计与实现](https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html)



## Hash（哈希）

### Hash 扩容过程

两张Hash表，平常起作用的都是0号表，当装载因子超过阈值时就会进行Rehash，将0号每上每一个bucket慢慢移动到1号表，所以叫渐进式Rehash，这种方式可以减少迁移系统的影响。

#### Rehash 过程

当周期函数发现为装载因子超过阈值时就会进行Rehash，Rehash的流程大概分成三步：

1. 生成新Hash表`ht[1]`，为 `ht[1]` 分配空间。此时字典同时持有`ht[0]`和`ht[1]`两个哈希表。字典的偏移索引从静默状态`-1`，设置为`0`，表示 Rehash 工作正式开始。
2. 迁移`ht[0]`数据到`ht[1]`。在 Rehash 进行期间，每次对字典执行增删查改操作，程序会顺带迁移一个`ht[0]`上的数据，并更新偏移索引。与此同时，周期函数也会定时迁移一批。
3. `ht[1]`和`ht[0]`指针对象交换。随着字典操作的不断执行， 最终在某个时间点上，`ht[0]`的所有键值对都会被 Rehash至 `ht[1]`，此时再将`ht[1]`和`ht[0]`指针对象互换，同时把偏移索引的值设为`-1`，表示Rehash操作已完成。

![](https://images.yingwai.top/picgo/20210818174640.png ':size=80%')

#### 如果字典正在Rehash，此时有请求过来，Redis会怎么处理？

针对新增Key，是往`ht[1]`里面插入。针对读请求，先从`ht[0]`读，没找到再去`ht[1]`找。至于删除和更新，其实本质是先找到位置，再进行操作，所以和读请求一样，先找`ht[0]`，再找`ht[1]`，找到之后再进行操作。



## Zset（有序集合）

Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的，但分数(score)却可以重复。

当元素均小于64个字节且元素不超过128时使用的是ziplist；否则同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： 

* 添加和删除都需要修改skiplist，所以复杂度为`O(log(n))`。 
* 但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为`O(1)` 
* 其他的range操作复杂度一般为`O(log(n))`
* 如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为`O(n)`

### 跳表（skiplist）

跳表本质上是对链表的一种优化，通过逐层跳步采样的方式构建索引，以加快查找速度。如果只用普通链表，只能一个一个往后找。跳表就不一样了，可以高层索引，一次跳跃多个节点，如果找过头了，就用更下层的索引。

![](https://images.yingwai.top/picgo/20210719222002.png ':size=80%')

### 每个节点的层数

使用概率均衡的思路，确定新插入节点的层数。Redis使用随机函数决定层数。直观上来说，默认1层，和丢硬币一样，如果是正面就继续往上，这样持续迭代，最大层数32层。

可以看到，50%的概率被分配到第一层，25%的概率被分配到第二层，12.5%的概率被分配到第三层。这种方式保证了越上层数量越少，自然跨越起来越方便。

![](https://images.yingwai.top/picgo/20210719222049.png ':size=70%')

### Zset 为什么同时需要字典和跳表来实现？

Zset是一个有序列表，字典和跳表分别对应两种查询场景，字典用来支持按成员查询数据，跳表则用以实现高效的范围查询，这样两个场景，性能都做到了极致。



## 用过哪些数据结构？用在那些场景？

用过 `String`，用在存储保证接口幂等的 token 以及令牌桶限流中的令牌数量；

用过 `List`，用在标注系统初始化样本池时存储待获取的样本id。

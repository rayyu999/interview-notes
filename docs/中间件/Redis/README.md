# Redis



## 命令

### SETNX

```shell
SETNX key value
```

如果指定的 key 不存在，则创建并为其设置值，然后返回状态码 1；如果指定的 key 存在，则直接返回 0。如果返回值为 1，代表获得该锁；此时其他进程再次尝试创建时，由于 key 已经存在，则都会返回 0 ，代表锁已经被占用。

使用该命令能实现分布式锁。



## 数据结构

![](https://images.yingwai.top/picgo/20210720220433.png)

### Zset（有序集合）

Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的，但分数(score)却可以重复。

当元素均小于64个字节且元素不超过128时使用的是ziplist；否则同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： 

* 添加和删除都需要修改skiplist，所以复杂度为`O(log(n))`。 
* 但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为`O(1)` 
* 其他的range操作复杂度一般为`O(log(n))`
* 如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为`O(n)`

### 跳表（skiplist）

跳表本质上是对链表的一种优化，通过逐层跳步采样的方式构建索引，以加快查找速度。如果只用普通链表，只能一个一个往后找。跳表就不一样了，可以高层索引，一次跳跃多个节点，如果找过头了，就用更下层的索引。

![](https://images.yingwai.top/picgo/20210719222002.png)

#### 每个节点的层数

使用概率均衡的思路，确定新插入节点的层数。Redis使用随机函数决定层数。直观上来说，默认1层，和丢硬币一样，如果是正面就继续往上，这样持续迭代，最大层数32层。

可以看到，50%的概率被分配到第一层，25%的概率被分配到第二层，12.5%的概率被分配到第三层。这种方式保证了越上层数量越少，自然跨越起来越方便。

![](https://images.yingwai.top/picgo/20210719222049.png)

#### Zset 为什么同时需要字典和跳表来实现？

Zset是一个有序列表，字典和跳表分别对应两种查询场景，字典用来支持按成员查询数据，跳表则用以实现高效的范围查询，这样两个场景，性能都做到了极致。



### 用过哪些数据结构？用在那些场景？

用过 `String`，用在存储保证接口幂等的 token 以及令牌桶限流中的令牌数量；

用过 `List`，用在标注系统初始化样本池时存储待获取的样本id。



## 集群模式

Redis 支持三种集群方案：

* 主从复制模式
* Sentinel（哨兵）模式
* Cluster 模式

https://segmentfault.com/a/1190000022808576



### 一致性 Hash

传统的Hash分片，可以将某个Key，落到某个节点。但有一个问题，当节点扩容或者缩容，路由会被完全打乱。如果是缓存场景，很容易造成缓存雪崩问题。

![](https://images.yingwai.top/picgo/20210721155501.png)

为了优化这种情况，一致性Hash就应运而生了。一致性Hash是说将数据和服务器，以相同的Hash函数，映射到同一个Hash环上，针对一个对象，在哈希环上顺时针查找距其最近的机器，这个机器就负责处理该对象的相关请求。

这种情况下，增加节点，只会分流后面一个节点的数据。减少节点，那么请求会由后一个节点继承。也就是说，节点变化操作，最多只会影响后面一个节点的数据。

![](https://images.yingwai.top/picgo/20210721155521.png)

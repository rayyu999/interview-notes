

# 系统容灾 & 性能优化



## 持久化机制

Redis 可以通过持久化机制，备份数据。有两种方式，一种是开启 RDB，RDB 是 Redis 的二进制快照文件，优点是文件紧凑，占用空间小，恢复速度比较快。同时，由于是子进程 Fork 的模式，对 Redis 本身读写性能的影响很小。

![](https://images.yingwai.top/picgo/20210810155442.png ':size=60%')

另一种方式是 AOF，AOF 中记录了 Redis 的操作命令，可以重放请求恢复现场，AOF 的文件会比 RDB 大很多。

出于性能考虑，如果开启了AOF，会将命令先记录在 AOF 缓冲，之后再刷入磁盘。数据刷入磁盘的时机根据参数决定，有三种模式：**1.关闭时刷入；2.每秒定期刷入；3.执行命令后立刻触发。**

AOF 的优点是故障情况下，丢失的数据会比 RDB 更少。如果是执行命令后立马刷入，AOF 会拖累执行速度，所以一般都是配置为每秒定期刷入，这样对性能影响不会很大。

![](https://images.yingwai.top/picgo/20210810155502.png ':size=60%')

### AOF 重写

Redis 可以在 AOF 文件体积变得过大时，自动地在后台 Fork 一个子进程，专门对 AOF 进行重写。说白了，就是针对相同 Key 的操作，进行合并，比如同一个 Key 的 set 操作，那就是后面覆盖前面。

在重写过程中，Redis 不但将新的操作记录在原有的 AOF 缓冲区，而且还会记录在 AOF 重写缓冲区。一旦新 AOF 文件创建完毕，Redis 就会将重写缓冲区内容，追加到新的 AOF 文件，再用新 AOF 文件替换原来的 AOF 文件。

![](https://images.yingwai.top/picgo/20210810155526.png ':size=60%')



## 集群模式

Redis 支持三种[集群方案](https://segmentfault.com/a/1190000022808576)：

* 主从复制模式
* Sentinel（哨兵）模式
* Cluster 模式



### 主从复制模式

为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。

为此， **Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上**。

在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

**总结：引入主从复制机制的目的有两个**

- 一个是读写分离，分担 "master" 的读写压力
- 一个是方便做容灾恢复

#### 主从复制原理

![](https://images.yingwai.top/picgo/20210722221843.png ':size=34%')

- 从数据库启动成功后，连接主数据库，发送 SYNC 命令；
- 主数据库接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；
- 主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令；
- 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照；
- 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令；
- 从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（**从数据库初始化完成**）
- 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（**从数据库初始化完成后的操作**）
- 出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库，增量复制。
- 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。



### Sentinel（哨兵）模式

第一种主从同步/复制的模式，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。Redis 本身不能自动切换主从，但可以写脚本实现，只是需要考虑的问题比较多。这不是一种推荐的方式，更多时候，我们优先考虑[哨兵模式](https://dunwu.github.io/db-tutorial/nosql/redis/redis-sentinel.html)。

哨兵来监测 Redis 服务是否正常，异常情况下，由哨兵代理切换。为避免哨兵成为单点，哨兵也需要多机部署。

![](https://images.yingwai.top/picgo/20210722222300.png ':size=50%')

#### 哨兵模式作用

- 通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器；
- 当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机；

然而一个哨兵进程对 Redis 服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。

#### 故障切换过程

假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。这样对于客户端而言，一切都是透明的。

**工作方式：**

- 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器，Slave 从服务器以及其他 Sentinel（哨兵）进程发送一个 `PING` 命令。
- 如果一个实例（instance）距离最后一次有效回复 `PING` 命令的时间超过 `down-after-milliseconds` 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（`SDOWN`）
- 如果一个 Master 主服务器被标记为主观下线（`SDOWN`），则正在监视这个 Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态
- 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（`SDOWN`）， 则 Master 主服务器会被标记为客观下线（`ODOWN`）
- 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有 Master 主服务器、Slave 从服务器发送 `INFO` 命令。
- 当 Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（`ODOWN`）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 `INFO` 命令的频率会从 10 秒一次改为每秒一次。
- 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel（哨兵）进程发送 `PING` 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

> `PING` 命令用于检查 Redis 服务器状态；
>
> `INFO` 命令用于获取各服务器的信息，了解它们的主从关系。

#### Master 挂掉后 Slave 的选择

当哨兵集群选举出哨兵Leader后，由哨兵Leader从Redis从节点中选择一个Redis节点作为主节点：

1. 过滤故障的节点；
2. 选择优先级slave-priority最大的从节点作为主节点，如不存在，则继续；
3. 选择复制偏移量最大的从节点作为主节点，如果都一样，则继续。这里解释下，数据偏移量记录写了多少数据，主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步；
4. 选择runid最小的从节点作为主节点。Redis每次启动的时候生成随机的runid作为Redis的标识。

![](https://images.yingwai.top/picgo/20210810155657.png ':size=45%')

#### 哨兵 Leader

每一个哨兵节点都可以成为Leader，当一个哨兵节点确认Redis集群的主节点主观下线后，会请求其他哨兵节点要求将自己选举为Leader。被请求的哨兵节点如果没有同意过其他哨兵节点的选举请求，则同意该请求，也就是选举票数+1，否则不同意。

如果一个哨兵节点获得的选举票数**超过节点数的一半，且大于quorum配置的值**，则该哨兵节点选举为Leader；否则重新进行选举。

![](https://images.yingwai.top/picgo/20210810155731.png ':size=60%')



### Cluster 集群模式

Redis Cluster 是一种服务器 Sharding 技术，3.0版本开始正式提供。

Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，**也就是说每台 Redis 节点上存储不同的内容**。

如果数据太大，可以使用**集群模式**。也就是将数据分片，不同的Key根据Hash路由到不同的节点。集群索引是通过一致性Hash算法来完成，这种算法可以解决服务器数量发生改变时，所有的服务器缓存在同一时间失效的问题。

同时，基于Gossip协议，集群状态变化时，如新节点加入、节点宕机、Slave提升为新Master，这些变化都能传播到整个集群的所有节点并达成一致。

![](https://images.yingwai.top/picgo/20210722231130.png ':size=58%')

#### 集群的数据分片

Redis 集群没有使用一致性 hash，而是引入了哈希槽【hash slot】的概念。所有的键根据哈希函数（CRC16[key]&16383）映射到0－16383槽内，共16384个槽位，每个节点维护部分槽及槽所映射的键值数据。

为了保证高可用，集群引入了主从复制模型，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点 `PING` 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点 A1 都宕机了，那么该集群就无法再提供服务了。



### 一致性 Hash

传统的Hash分片，可以将某个Key，落到某个节点。但有一个问题，当节点扩容或者缩容，路由会被完全打乱。如果是缓存场景，很容易造成缓存雪崩问题。

![](https://images.yingwai.top/picgo/20210721155501.png ':size=60%')

为了优化这种情况，一致性Hash就应运而生了。一致性Hash是说将数据和服务器，以相同的Hash函数，映射到同一个Hash环上，针对一个对象，在哈希环上顺时针查找距其最近的机器，这个机器就负责处理该对象的相关请求。

这种情况下，增加节点，只会分流后面一个节点的数据。减少节点，那么请求会由后一个节点继承。也就是说，节点变化操作，最多只会影响后面一个节点的数据。

![](https://images.yingwai.top/picgo/20210721155521.png ':size=60%')

**参考链接：**

* [Redis系列之——一致性Hash](https://juejin.cn/post/6850418113830846471)
* [Redis集群扩展知识点：一致性hash与hash slot](https://www.jianshu.com/p/70ca5d2481b3)



## Redis 性能

只能说在十万级。使用之前，要跑BenchMark，实际情况下会受带宽、负载、单个数据大小、是否开启多线程等因素影响，脱开具体场景谈性能，就没有意义。

* [Redis 性能测试](https://www.runoob.com/redis/redis-benchmarks.html)

* [为什么 Redis 单线程能达到百万+QPS？](https://segmentfault.com/a/1190000022998384)



## 线程模型

Redis是单线程Reactor模型，通过高效的IO复用以及内存处理实现高性能。如果是6.0之前是完全的单线程；6.0之后，IO解包通过多线程进行了优化，而处理逻辑，还是单线程。

另外，如果考虑到RDB的Fork，一些定时任务的处理，那么Redis也可以说多进程。但是Redis对数据的处理，至始至终，都是单线程。

![](https://images.yingwai.top/picgo/20210722233334.png ':size=60%')



## 6.0版本的多线程功能

多线程功能，主要用于提高解包的效率。和传统的Multi Reactor多线程模型不同，Redis的多线程只负责处理网络IO的解包和协议转换，一方面是因为Redis的单线程处理足够快，另一方面也是为了兼容性做考虑。

![](https://images.yingwai.top/picgo/20210722233508.png ':size=60%')

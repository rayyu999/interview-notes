# 场景应用



## 缓存



## 分布式锁

在系统中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失。在单服务器系统我们常用本地锁来避免并发带来的问题，然而，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。

锁是计算机领域一个非常常见的概念，分布式锁也依赖存储组件，针对请求量的不同，可以选择Etcd、MySQL、Redis等。前两者可靠性更强，Redis性能更高。

![](https://images.yingwai.top/picgo/20210726221237.png)

### 实现

想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示**SET** if **N**ot e**X**ists，即如果 key 不存在，才会设置它的值，否则什么也不做。

两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁：

```shell
SETNX lock 1
(integer) 1		// 客户端1加锁成功

SETNX lock 1
(integer) 0		// 客户端2申请加锁，因为后到达，加锁失败
```

操作完成后还要及时释放锁：

```shell
DEL lock 		// 释放锁
(integer) 1
```

![](https://images.yingwai.top/picgo/20210726222219.jpg)

### 死锁

上面的步骤存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：

1. 程序处理业务逻辑异常，没及时释放锁
2. 进程挂了，没机会释放锁

这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。

#### 避免死锁

上述问题的解决方案也很简单，在申请锁时设置一个过期时间即可。注意这里不能把获取锁和设置过期时间的命令分开，避免出现获取锁成功但由于服务器宕机或网络等问题造成 `EXPIRE` 命令没有执行的极端情况出现，因此要使用 `SET lock EX 10 NX` 命令。

但这种场景下还是存在问题：

1. 客户端 1 加锁成功，开始操作共享资源
2. 客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」
3. 客户端 2 加锁成功，开始操作共享资源
4. 客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）

### 锁过期

锁过期产生的原因是当前客户端操作共享资源耗时太久，导致锁被自动释放，之后被别的客户端持有。

容易想到事先预估某个操作需要执行的时间，然后根据这个预估的时间来设置过期时间。这样确实可以缓解锁过期的问题，降低出问题的概率，但无法彻底解决问题。

比较好的方法是：**加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。**Redisson 就封装好了这些工作。

![](https://images.yingwai.top/picgo/20210727172117.jpg)

### 锁被别人释放

在死锁那里提到，潜在的问题还有客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁。这种情况的解决方法是**在加锁时，设置一个只有自己知道的「唯一标识」进去**：

```shell
// 锁的VALUE设置为UUID
127.0.0.1:6379> SET lock $uuid EX 20 NX
OK
```

然后释放时要判断锁是否是自己持有，是才进行释放（伪代码）：

```java
if (redis.get("lock") == $uuid) {
    redis.del("lock");
}
```

因为这里是两条命令，因此为了保证原子性，可以借助Lua脚本来执行。因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。

### 主从发生切换

1. 客户端 1 在主库上执行 SET 命令，加锁成功
2. 此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）
3. 从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！

针对这个问题，Redis 作者提出了 **Redlock**。



**参考链接：**

* [分布式锁的实现之 redis 篇](https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/)
* [深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了！](http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/)


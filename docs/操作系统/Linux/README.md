# Linux

* [LINUX的进程、线程、文件描述符是什么](https://labuladong.gitee.io/algo/6/48/)
* [LINUX 文件系统都是什么鬼](https://labuladong.gitee.io/algo/6/47/)

## 进程

在 Linux 系统中，进程和线程几乎没有区别，Linux 中的进程就是一个数据结构。

抽象地说，计算机如下图：

![](https://images.yingwai.top/picgo/20210810225645.png)

大矩形表示计算机的**内存空间**，其中的小矩形表示**进程**，左下角的圆形表示**磁盘**，右下角的图形表示**输入输出设备**，比如鼠标键盘显示器等。内存空间又被划分为两块，上半部分表示**用户空间**，下半部分表示**内核空间**。

⽤户空间装着⽤户进程需要使⽤的资源，⽐如你在程序代码⾥开⼀个数组，这个数组肯定存在⽤户空间；内核空间存放内核进程需要加载的系统资源，这⼀些资源⼀般是不允许⽤户访问的。但是注意有的⽤户进程会共享⼀些内核空间的资源，⽐如⼀些动态链接库等等。

用编程语言写一个程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 `hello world`，然后程序退出。在操作系统层面，就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。

**编译好的可执行程序只是一个文件**，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等待，进程创建好之后，读入程序，程序才被系统执行。

操作系统是如何创建进程的？**对于操作系统，进程就是一个数据结构**，Linux 源码如下：

```c
struct task_struct {
    // 进程状态
    long state;
    // 虚拟内存结构体
    struct mm_struct *mm;
    // 进程号
    pid_t pid;
    // 指向父进程的指针
    struct task_struct_rcu *parent;
    // 子进程列表
    struct list_head children;
    // 存放文件系统信息的指针
    struct fs_struct *fs;
    // 一个数组，包含该进程打开的文件指针
    struct files_struct *files;
};
```

`task_struct` 就是 Linux 内核对于一个进程的描述，也可以称为 *进程描述符*。源码比较复杂，这里只截取了一小部分比较常见的。

其中的 `mm` 指针指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；`files` 指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。

### [守护进程、僵尸进程、孤儿进程](https://www.jianshu.com/p/7390f73ad668)

***进程是资源封装的单位。***进程封装的资源包括：内存、文件、文件系统、信号、控制台等等。一个进程区别于另外一个进程的标记就是占有的资源完全不一样。那么在任何一个OS中描述进程，我们只需要去描述它的资源即可。通常我们使用一个数据结构PCB（Process Control Block）进程控制块来描述一个进程。上面也有提到对于Linux操作系统，我们使用 `task_struct` 描述一个进程。

在unix/linux中，正常情况下子进程是通过父进程创建的。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用 `wait()` 或者 `waitpid()` 系统调用取得子进程的终止状态。

#### 守护进程

Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。

守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。

一个守护进程的父进程是 init 进程，因为它真正的父进程在 `fork()` 出子进程后就先于子进程 `exit()` 退出了，所以它是一个由 init 继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备 stdout 还是标准出错设备 stderr 的输出都需要特殊处理。

守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。

#### [僵尸进程](https://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/)

一个进程使用 `fork()` 创建子进程，如果子进程退出，而父进程并没有调用 `wait()` 或 `waitpid()` 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

##### 僵尸进程的危害

unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件,占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID、退出状态the termination status of the process、运行时间the amount of CPU time taken by the process等）。直到父进程通过 wait / waitpid 来取时才释放。但这样就导致了问题，如果进程不调用 wait / waitpid 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

任何一个子进程（init除外）在 `exit()` 之后，并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在 `exit()` 之后，父进程没有来得及处理，这时用 ps 命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用 ps 命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由 init 接管。init 将会以父进程的身份对僵尸状态的子进程进行处理。

一个进程如果只复制 `fork` 子进程而不负责对子进程进行 `wait()` 或是 `waitpid()` 调用来释放其所占有资源的话，那么就会产生很多的僵死进程，如果要消灭系统中大量的僵死进程，只需要将其父进程杀死，此时所有的僵死进程就会编程孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵死进程所占有的资源，从而结束僵死进程。

#### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程给收养，所以孤儿进程不会对系统造成危害。



## 文件描述符

`files` 是一个文件指针数组。一般来说，一个进程会从 `files[0]` 读取输入，将输出写入 `files[1]`，将错误信息写入 `files[2]`。

**每个进程被创建时，`files` 的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引**，索引程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。

![](https://images.yingwai.top/picgo/20210810230419.png)

对于⼀般的计算机，输⼊流是键盘，输出流是显⽰器，错误流也是显⽰器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过「系统调⽤」让内核进程访问硬件资源。

PS：不要忘了，Linux 中⼀切都被抽象成⽂件，设备也是⽂件，可以进⾏读
和写。

如果我们写的程序需要其他资源，⽐如打开⼀个⽂件进⾏读写，这也很简单，进⾏系统调⽤，让内核把⽂件打开，这个⽂件就会被放到 files 的第 4 个位置：

![](https://images.yingwai.top/picgo/20210830174155.png ':size=50%')

明⽩了这个原理，**输⼊重定向**就很好理解了，程序想读取数据的时候就会去 `files[0]` 读取，所以我们只要把 `files[0]` 指向⼀个⽂件，那么程序就会从这个⽂件中读取数据，⽽不是从键盘：

```shell-session
$ command < file.txt
```

![](https://images.yingwai.top/picgo/20210830174305.png ':size=50%')

同理，**输出重定向**就是把 `files[1]` 指向⼀个⽂件，那么程序的输出就不会写⼊到显⽰器，⽽是写⼊到这个⽂件中：

```shell-session
$ command > file.txt
```

![](https://images.yingwai.top/picgo/20210830174705.png ':size=50%')

错误重定向也是⼀样的，就不再赘述。

管道符其实也是异曲同⼯，把⼀个进程的输出流和另⼀个进程的输⼊流接起⼀条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美：

```shell-session
$ cmd1 | cmd2 | cmd3
```

![](https://images.yingwai.top/picgo/20210830174800.png ':size=50%')

到这⾥，你可能也看出「Linux 中⼀切皆⽂件」设计思路的⾼明了，不管是设备、另⼀个进程、socket 套接字还是真正的⽂件，全部都可以读写，统⼀装进⼀个简单的 `files` 数组，进程通过简单的⽂件描述符访问相应资源，具体细节交于操作系统，有效解耦，优美⾼效。



## 线程

⾸先要明确的是，多进程和多线程都是并发，都可以提⾼处理器的利⽤效率，所以现在的关键是，多线程和多进程有啥区别。

为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的⾓度来看，并没有把线程和进程区别对待。

我们知道系统调⽤ `fork()` 可以新建⼀个⼦进程，函数 `pthread()` 可以新建⼀个线程。**但⽆论线程还是进程，都是⽤ `task_struct` 结构表⽰的，唯⼀的区别就是共享的数据区域不同。**

换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其⽗进程是共享的，⽽⼦进程是拷⻉副本，⽽不是共享。就⽐如说， `mm` 结构和 `files` 结构在线程中都是共享的，我画两张图你就明⽩了：

![](https://images.yingwai.top/picgo/20210830175006.png ':size=50%')

![](https://images.yingwai.top/picgo/20210830175020.png ':size=50%')

所以说，我们的多线程程序要利⽤锁机制，避免多个线程同时往同⼀区域写⼊数据，否则可能造成数据错乱。

那么你可能问，**既然进程和线程差不多，⽽且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使⽤⽐多进程普遍得多呢？**

因为现实中数据共享的并发更普遍，⽐如⼗个⼈同时从⼀个账户取⼗元，我们希望的是这个共享账户的余额正确减少⼀百元，⽽不是希望每⼈获得⼀个账户的拷⻉，每个拷⻉账户减少⼗元。

当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其特有的数据结构，我个⼈认为不如 Linux 的这种设计简洁，增加了系统的复杂度。

在 Linux 中新建线程和进程的效率都是很⾼的，对于新建进程时内存区域拷⻉的问题，Linux 采⽤了 copy-on-write 的策略优化，也就是并不真正复制⽗进程的内存空间，⽽是等到需要写操作时才去复制。**所以 Linux 中新建进程和新建线程都是很迅速的。**

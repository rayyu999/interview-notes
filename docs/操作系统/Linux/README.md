# Linux



## 进程

在 Linux 系统中，进程和线程几乎没有区别，Linux 中的进程就是一个数据结构。

抽象地说，计算机如下图：

![](https://images.yingwai.top/picgo/20210810225645.png)

大矩形表示计算机的**内存空间**，其中的小矩形表示**进程**，左下角的圆形表示**磁盘**，右下角的图形表示**输入输出设备**，比如鼠标键盘显示器等。内存空间又被划分为两块，上半部分表示**用户空间**，下半部分表示**内核空间**。

⽤户空间装着⽤户进程需要使⽤的资源，⽐如你在程序代码⾥开⼀个数组，这个数组肯定存在⽤户空间；内核空间存放内核进程需要加载的系统资源，这⼀些资源⼀般是不允许⽤户访问的。但是注意有的⽤户进程会共享⼀些内核空间的资源，⽐如⼀些动态链接库等等。

用编程语言写一个程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 `hello world`，然后程序退出。在操作系统层面，就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。

**编译好的可执行程序只是一个文件**，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等待，进程创建好之后，读入程序，程序才被系统执行。

操作系统是如何创建进程的？**对于操作系统，进程就是一个数据结构**，Linux 源码如下：

```c
struct task_struct {
    // 进程状态
    long state;
    // 虚拟内存结构体
    struct mm_struct *mm;
    // 进程号
    pid_t pid;
    // 指向父进程的指针
    struct task_struct_rcu *parent;
    // 子进程列表
    struct list_head children;
    // 存放文件系统信息的指针
    struct fs_struct *fs;
    // 一个数组，包含该进程打开的文件指针
    struct files_struct *files;
};
```

`task_struct` 就是 Linux 内核对于一个进程的描述，也可以称为 *进程描述符*。源码比较复杂，这里只截取了一小部分比较常见的。

其中的 `mm` 指针指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；`files` 指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。



## 文件描述符

`files` 是一个文件指针数组。一般来说，一个进程会从 `files[0]` 读取输入，将输出写入 `files[1]`，将错误信息写入 `files[2]`。

**每个进程被创建时，`files` 的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引**，索引程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。

![](https://images.yingwai.top/picgo/20210810230419.png)


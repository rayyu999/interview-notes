# 32. 最长有效括号

https://leetcode-cn.com/problems/longest-valid-parentheses/

## 题目描述

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

 

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```



**提示：**

* `0 <= s.length <= 3 * 10^4`
* `s[i]` 为 `'('` 或 `')'`



## 思路

动态规划：

维护一个数组 `dp`，`dp[i]` 表示以 `s` 中第 `i` 个字符结尾的子串的最长合法序列的长度。根据题意分类讨论：

* `s.charAt(i) == '('`：
  * 以它为结尾的子串无论如何都不合法，因此 `dp[i] = 0`；
* `s.charAt(i) == ')'`：
  * 若 `s.charAt(i-1) == '('`，则当前字符可以与上一个字符组成一个合法序列，先令 `dp[i] = 2`；
  * 若 `s.charAt(i-1) == ')'`，则要判断是否存在嵌套的情况。可以找到以第 `i-1` 个字符结尾的合法子串的起点 `j = i - 1 - dp[i-1]`，判断 `s.charAt(j)` 是否为 `'('`，若是则先令 `dp[i] = dp[i-1] + 2`；否则 `dp[i] = 0`；
  * 在设置了当前合法序列的长度后，还需要判断当前合法序列是否与另外一个合法序列是连续的。可以找到当前合法序列的起点 `k = i - dp[i]`，然后令 `dp[i] += dp[k]`。

其实 `s.charAt(i) == ')'` 时讨论的两种情况能合并为一种，因为第一种情况恰好是第二种情况的特例（`dp[i-1] = 0` -> `j = i-1`）。



## 代码

```java
class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length(), max = 0;
        int[] dp = new int[n];
        for (int i = 0; i < n; ++i) {
            char c = s.charAt(i);
            if (c == ')') {
                if (i > 0) {
                    if (s.charAt(i-1) == '(') {
                        // 与上一位组成一个合法序列（这一条判断其实可以直接省略）
                        dp[i] = 2;
                    } else if (i-1-dp[i-1] >= 0 && s.charAt(i-1-dp[i-1]) == '(') {
                        // 嵌套的情况
                        dp[i] = dp[i-1] + 2;
                    }
                    // 查看当前合法序列能否拼到前面的合法序列中
                    if (i - dp[i] >= 0) {
                        dp[i] += dp[i-dp[i]];
                    }
                }
            }
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
```


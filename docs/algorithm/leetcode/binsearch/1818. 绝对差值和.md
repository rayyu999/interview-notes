# 1818. 绝对差值和

https://leetcode-cn.com/problems/minimum-absolute-sum-difference/

## 题目描述

你两个正整数数组 `nums1` 和 `nums2` ，数组的长度都是 `n` 。

数组 `nums1` 和 `nums2` 的 绝对差值和 定义为所有 `|nums1[i] - nums2[i]|`（`0 <= i < n`）的 总和（下标从 `0` 开始）。

你可以选用 `nums1` 中的 任意一个 元素来替换 `nums1` 中的 至多 一个元素，以 最小化 绝对差值和。

在替换数组 `nums1` 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 `10^9 + 7` 取余 后返回。

`|x|` 定义为：

如果 `x >= 0` ，值为 `x` ，或者
如果 `x <= 0` ，值为 `-x`



**示例 1：**

```
输入：nums1 = [1,7,5], nums2 = [2,3,5]
输出：3
解释：有两种可能的最优方案：

- 将第二个元素替换为第一个元素：[1,7,5] => [1,1,5] ，或者
- 将第二个元素替换为第三个元素：[1,7,5] => [1,5,5]
两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3
```

**示例 2：**

```
输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
输出：0
解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0
```

**示例 3：**

```
输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
输出：20
解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] => [10,10,4,4,2,7]
绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20
```



**提示：**

* `n == nums1.length`
* `n == nums2.length`
* `1 <= n <= 10^5`
* `1 <= nums1[i], nums2[i] <= 10^5`



## 思路

排序+二分查找：

根据题意，单个二元组 `nums1[i]` 和 `nums2[i]` 对差值和的贡献为 `|nums1[i] - nums2[i]|`。而将 `nums1[i]` 替换为 `nums1[j]` 后变为 `|nums1[j] - nums2[i]|`，替换后与原来的差值和之差为：

* `|nums1[i] - nums2[i]| - |nums1[j] - nums2[i]|`

于是为了使得最终的差值和最小，我们应该使上面这条式子的值尽可能地大，也就是对于每个当前访问的元素 `nums1[i]`，要到 `nums1` 中找到与 `nums2[i]` 最接近的数然后替换。于是可以构造一个新数组，里面元素都是 `nums1` 中的元素并且按升序排序，然后每访问到一个元素，就利用二分查找到 `nums1` 中找最接近的元素并按上面的式子更新差值和的最大差值，最后返回原差值和减去这个最大差值即可。



## 代码

```java
class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        // sumDiff计算数组的原差值和，maxDiff记录使差值变化最大的替换差值
        int n = nums1.length, sumDiff = 0, maxDiff = 0;
        int[] nums3 = (int[])Arrays.copyOf(nums1, n);
        int MOD = 1000000007;
        Arrays.sort(nums3);
        for (int i = 0; i < n; ++i) {
            int curDiff = Math.abs(nums1[i] - nums2[i]);
            sumDiff = (sumDiff + curDiff) % MOD;
            // 寻找最接近的元素
            int j = binsearch(nums3, n, nums2[i]);
            // 更新最大替换差值
            int changeDiff = curDiff - Math.abs(nums3[j] - nums2[i]);
            maxDiff = Math.max(maxDiff, changeDiff);
        }
        return (sumDiff - maxDiff + MOD) % MOD;
    }

    private int binsearch(int[] nums3, int n, int target) {
        int l = 0, r = n - 1;
        while (l < r - 1) {
            int mid = l + (r - l >> 1);
            if (nums3[mid] == target) {
                return mid;
            } else if (nums3[mid] > target) {
                r = mid;
            } else {
                l = mid;
            }
        }
        // 循环到最后剩余两个元素，返回更接近的那个
        return Math.abs(nums3[l] - target) < Math.abs(nums3[r] - target) ? l : r;
    }
}
```


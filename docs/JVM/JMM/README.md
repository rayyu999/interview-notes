# Java 内存模型（JMM）

## [JMM 是什么？](https://zhuanlan.zhihu.com/p/258393139)

JMM就是Java内存模型(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以**java内存模型(JMM)屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。**

Java内存模型规定**所有的变量都存储在主内存**中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，**线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行**。**线程不能直接读写主内存中的变量**。

![](http://images.yingwai.top/picgo/20210716231719.jpg)

**两条规定：**

1. 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。
2. 不同线程之间`无法直接访问`其他线程工作内存中的变量，`线程间值的传递需要通过主内存来完成`。



## JMM 定义了什么？

* **原子性：**指一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。
* **可见性：**指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。（利用 `volatile` 关键字实现）
* **有序性：**指代码按某种顺序执行（`volatile` 通过内存屏障禁止指令重排，而 `synchronized` 是通过锁实现代码块在多线程间串行执行）



## 八种内存交互操作

![](http://images.yingwai.top/picgo/20210716232311.jpg)

- `lock`（锁定）：作用于**主内存**中的变量，把变量标识为线程独占的状态。
- `read`（读取）：作用于**主内存**的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。
- `load`（加载）：作用于**工作内存**的变量，把read操作主存的变量放入到工作内存的变量副本中。
- `use`（使用）：作用于**工作内存**的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- `assign`（赋值）：作用于**工作内存**的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。
- `store`（存储），作用于**工作内存**的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。
- `write`（写入）：作用于**主内存**中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
- `unlock`（解锁）：作用于**主内存**的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

### 内存交互操作规则

- 不允许`read`、`load`、`store`、`write`操作之一单独出现，也就是`read`操作后必须`load`，`store`操作后必须`write`。
- 不允许线程丢弃他最近的`assign`操作，即工作内存中的变量数据改变了之后，必须告知主存。
- 不允许线程将没有`assign`的数据从工作内存同步到主内存。
- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施`use`、`store`操作之前，必须经过`load`和`assign`操作。
- 一个变量同一时间只能有一个线程对其进行`lock`操作。多次`lock`之后，必须执行相同次数`unlock`才可以解锁。
- 如果对一个变量进行`lock`操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新`load`或`assign`操作初始化变量的值。
- 如果一个变量没有被`lock`，就不能对其进行`unlock`操作。也不能`unlock`一个被其他线程锁住的变量。
- 一个线程对一个变量进行`unlock`操作之前，必须先把此变量同步回主内存。



## [指令重排序](https://blog.csdn.net/lovewebeye/article/details/79728688)

在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。

编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
但是，可以通过插入特定类型的`Memory Barrier`来禁止特定类型的编译器重排序和处理器重排序。

### 数据依赖性

如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。 

编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。

### as-if-serial

不管怎么重排序，单线程下的执行结果不能被改变。

编译器、runtime和处理器都必须遵守 as-if-serial 语义。

### 内存屏障（Memory Barrier）

上面讲到了，通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。

内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：

1. 保证特定操作的执行顺序。
2. 影响某些数据（或则是某条指令的执行结果）的内存可见性。

### happens-before

在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。

具体的一共有六项规则：

1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
5. start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
6. join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
7. 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
8. 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。

注意：两个操作之间具有 happens-before 关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。下面以一个具体的例子来讲下如何使用这些规则进行推论：

```java
double pi  = 3.14;    //A
double r   = 1.0;     //B
double area = pi * r * r; //C
```

依旧以上面计算圆面积的进行描述。利用程序顺序规则（规则1）存在三个happens-before关系：

1. A happens-before B
2. B happens-before C
3. A happens-before C

这里的第三个关系是利用传递性进行推论的。A happens-before B，定义1要求A执行结果对B可见，并且A操作的执行顺序在B操作之前，但与此同时利用定义中的第二条，A，B操作彼此不存在数据依赖性，两个操作的执行顺序对最终结果都不会产生影响，在不改变最终结果的前提下，允许A，B两个操作重排序，即**happens-before关系并不代表了最终的执行顺序。**

### [as-if-serial 与 happens-before 的区别](https://thinkwon.blog.csdn.net/article/details/102074107?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control)

* as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。
* as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。
* as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。



##  讲讲 `volatile` 关键字

很多并发编程都使用了`volatile`关键字，主要的作用包括两点：

1. **保证线程间变量的可见性。**
2. **禁止CPU进行指令重排序。**

### 可见性

volatile修饰的变量，当一个线程改变了该变量的值，其他线程是立即可见的。普通变量则需要重新读取才能获得最新值。

volatile保证可见性的流程大概就是这个一个过程：

![](https://images.yingwai.top/picgo/20210806181546.png)

注意 volatile 不能保证线程安全，因为它不能保证原子性。

### 禁止指令重排序

重排序的种类分为三种，分别是：编译器重排序，指令级并行的重排序，内存系统重排序。整个过程如下所示：

![](https://images.yingwai.top/picgo/20210827170019.png)
